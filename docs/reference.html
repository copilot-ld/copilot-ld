<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Copilot-LD â€“ Implementation Reference</title>
    <link rel="icon" href="favicon.svg" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css"
    />
    <link rel="stylesheet" href="assets/main.css" />
  </head>

  <body>
    <header class="container">
      <hgroup>
        <h1>
          <a href="index.html">ðŸ§¬ <mark>Copilot-LD</mark></a>
        </h1>
        <p>An intelligent agent leveraging GitHub Copilot and Linked Data</p>
      </hgroup>
      <nav>
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="concepts.html">Concepts</a></li>
          <li>
            <details class="dropdown">
              <summary>Docs</summary>
              <ul>
                <li><a href="architecture.html">Architecture</a></li>
                <li><a href="reference.html" class="active">Reference</a></li>
              </ul>
            </details>
          </li>
          <li>
            <details class="dropdown">
              <summary>Guides</summary>
              <ul>
                <li><a href="configuration.html">Configuration</a></li>
                <li><a href="processing.html">Processing</a></li>
                <li><a href="deployment.html">Deployment</a></li>
                <li><a href="development.html">Development</a></li>
              </ul>
            </details>
          </li>
        </ul>
      </nav>
    </header>
    <main class="container">
      <h2>Implementation Reference</h2>

      <p>
        Detailed implementation information for developers working with or
        extending Copilot-LD. This guide covers service internals, package APIs,
        code generation, security implementation, and build processes.
      </p>

      <aside>
        <nav>
          <h5>Contents</h5>
          <ul>
            <li><a href="#services">Service Implementations</a></li>
            <li><a href="#packages">Package Catalog</a></li>
            <li><a href="#codegen">Code Generation</a></li>
            <li><a href="#security">Security Implementation</a></li>
            <li><a href="#docker">Docker Build Process</a></li>
            <li><a href="#patterns">Development Patterns</a></li>
            <li><a href="#extensions">Extension Development</a></li>
            <li><a href="#tools">Tool Development</a></li>
            <li><a href="#testing">Testing Strategies</a></li>
            <li><a href="#next">Next Steps</a></li>
          </ul>
        </nav>
        <hr />
      </aside>

      <h3 id="services">Service Implementations</h3>

      <h4>Agent Service</h4>

      <p>
        Central orchestrator that autonomously decides what tool calls to make
        and when. Requests are processed sequentially per request (readiness
        checks run in parallel). The service is built as a thin gRPC wrapper
        around business logic in the <code>@copilot-ld/libagent</code> package.
      </p>

      <p><strong>Core Components</strong>:</p>
      <ul>
        <li>
          <strong>AgentMind</strong>: Handles conversation setup, planning, and
          context assembly
        </li>
        <li>
          <strong>AgentHands</strong>: Executes tool calls and manages the tool
          calling loop
        </li>
      </ul>

      <p><strong>Architecture</strong>:</p>
      <ul>
        <li>
          <strong>Business logic library</strong>: Core logic in
          <code>@copilot-ld/libagent</code> for framework-agnostic orchestration
        </li>
        <li>
          <strong>Service adapter pattern</strong>: gRPC service delegates to
          <code>AgentMind</code> while handling authentication and communication
        </li>
        <li>
          <strong>Resource integration</strong>: Direct access to
          <code>ResourceIndex</code> with policy-based filtering
        </li>
        <li>
          <strong>Testability</strong>: Business logic can be unit tested
          without service infrastructure
        </li>
      </ul>

      <details>
        <summary>Message Assembly and Budgeting</summary>
        <ul>
          <li>
            <strong>Assembly order</strong>: <code>assistant</code> â†’
            <code>tasks</code> â†’ <code>tools</code> â†’ <code>history</code>
          </li>
          <li>
            <strong>Budgeting formula</strong>:
            <code
              >effective_budget = max(0, config.budget.tokens -
              assistant.content.tokens)</code
            >
          </li>
          <li>
            <strong>Allocation</strong>: Optional shaping for
            <code>tools</code> and <code>history</code> portions
          </li>
          <li>
            <strong>Autonomous decisions</strong>: Agent decides which tools to
            call without hard-wired dependencies
          </li>
        </ul>
      </details>

      <h4>Memory Service</h4>

      <p>
        Manages conversation memory using JSONL (newline-delimited JSON) storage
        for efficient appends. Provides memory windows with intelligent budget
        allocation. Built as a gRPC wrapper around
        <code>@copilot-ld/libmemory</code>.
      </p>

      <p><strong>Key Operations</strong>:</p>
      <ul>
        <li>
          <code>Append</code>: Adds resource identifiers with automatic
          deduplication
        </li>
        <li>
          <code>Get</code>: Returns memory window with budget-filtered tools and
          history
        </li>
      </ul>

      <p><strong>Architecture</strong>:</p>
      <ul>
        <li>
          <strong>Core classes</strong>: <code>MemoryWindow</code>,
          <code>MemoryIndex</code>, <code>MemoryFilter</code>
        </li>
        <li>
          <strong>Per-resource isolation</strong>: Each conversation has its own
          index and window
        </li>
        <li>
          <strong>On-demand initialization</strong>: Windows created and cached
          as needed
        </li>
        <li>
          <strong>Network coordination</strong>: Request locks ensure
          consistency during concurrent ops
        </li>
        <li>
          <strong><code>IndexBase</code> compliance</strong>: Extends standard
          patterns with <code>addItem()</code> and <code>queryItems()</code>
        </li>
        <li>
          <strong>JSONL storage</strong>: Append-only format for efficient
          operations
        </li>
      </ul>

      <h4>LLM Service</h4>

      <p>
        Interfaces with language models for embedding generation and text
        completion. Handles communication with external AI services (GitHub
        Copilot, OpenAI, etc.).
      </p>

      <p><strong>Key Operations</strong>:</p>
      <ul>
        <li>
          <code>CreateEmbeddings</code>: Generates vector embeddings from text
        </li>
        <li>
          <code>CreateCompletions</code>: Generates conversational responses
        </li>
      </ul>

      <p><strong>Implementation</strong>:</p>
      <ul>
        <li>
          <strong>Provider abstraction</strong>: Supports multiple LLM providers
        </li>
        <li>
          <strong>Batch processing</strong>: Optimizes API calls for embedding
          generation
        </li>
        <li>
          <strong>Error handling</strong>: Graceful degradation on API failures
        </li>
      </ul>

      <h4>Vector Service</h4>

      <p>
        Performs text-based similarity search operations against dual vector
        indexes (content and descriptor). Returns content strings directly for
        immediate use.
      </p>

      <p><strong>Key Operations</strong>:</p>
      <ul>
        <li>
          <code>QueryByContent</code>: Searches content index, returns matching
          content strings
        </li>
        <li>
          <code>QueryByDescriptor</code>: Searches descriptor index, returns
          matching descriptors
        </li>
      </ul>

      <p><strong>Architecture</strong>:</p>
      <ul>
        <li>
          <strong>Text-based interface</strong>: Accepts text, handles embedding
          internally via LLM
        </li>
        <li>
          <strong>Dual-index system</strong>: Separate content and descriptor
          indexes
        </li>
        <li>
          <strong>Direct content return</strong>: Returns strings, not just
          identifiers
        </li>
        <li>
          <strong>Resource integration</strong>: Uses
          <code>ResourceIndex</code> internally
        </li>
        <li>
          <strong>In-memory operations</strong>: Fast cosine similarity
          computation
        </li>
      </ul>

      <h4>Graph Service</h4>

      <p>
        Performs pattern-based queries against knowledge graphs using RDF graph
        patterns. Enables semantic search and ontology exploration.
      </p>

      <p><strong>Key Operations</strong>:</p>
      <ul>
        <li>
          <code>QueryByPattern</code>: Queries using subject, predicate, object
          patterns with wildcards
        </li>
        <li>
          <code>GetOntology</code>: Returns dataset ontology for query planning
        </li>
      </ul>

      <p><strong>Architecture</strong>:</p>
      <ul>
        <li>
          <strong>RDF graph patterns</strong>: Uses N3 store with SPARQL-like
          semantics
        </li>
        <li>
          <strong>Resource integration</strong>: Returns identifiers compatible
          with <code>ResourceIndex</code>
        </li>
        <li>
          <strong>Ontology support</strong>: Provides dataset structure
          information
        </li>
        <li>
          <strong>Wildcard matching</strong>: Null values act as wildcards in
          patterns
        </li>
      </ul>

      <h4>Tool Service</h4>

      <p>
        Acts as a gRPC proxy between LLM tool calls and actual implementations.
        Supports configuration-driven endpoint mapping to extend the platform
        with custom tools.
      </p>

      <p><strong>Key Operations</strong>:</p>
      <ul>
        <li>
          <code>Call</code>: Proxies tool calls to appropriate services via
          configuration
        </li>
        <li>
          <code>ListTools</code>: Returns OpenAI-compatible tool schemas for LLM
        </li>
      </ul>

      <p><strong>Architecture</strong>:</p>
      <ul>
        <li>
          <strong>Configuration-driven</strong>: Tools defined via YAML
          configuration
        </li>
        <li>
          <strong>Pure proxy</strong>: No business logic, only routing and
          protocol conversion
        </li>
        <li>
          <strong>Extensible</strong>: Maps to existing services or custom tool
          implementations
        </li>
        <li>
          <strong>Schema generation</strong>: Auto-generates JSON schemas from
          protobuf types
        </li>
      </ul>

      <h3 id="packages">Package Catalog</h3>

      <p>
        Business logic packages (<code>@copilot-ld/lib*</code>) provide
        framework-agnostic functionality that can be used in services, CLI
        tools, or other applications.
      </p>

      <h4>Core Packages</h4>

      <ul>
        <li>
          <strong>@copilot-ld/libagent</strong>: Agent orchestration logic
          (<code>AgentMind</code>, <code>AgentHands</code>)
        </li>
        <li>
          <strong>@copilot-ld/libmemory</strong>: Conversation memory management
          (<code>MemoryWindow</code>, <code>MemoryIndex</code>)
        </li>
        <li>
          <strong>@copilot-ld/libvector</strong>: Vector similarity operations
          and indexing
        </li>
        <li>
          <strong>@copilot-ld/libgraph</strong>: RDF graph operations and
          ontology management
        </li>
        <li>
          <strong>@copilot-ld/libresource</strong>: Resource management with
          policy filtering
        </li>
        <li>
          <strong>@copilot-ld/libpolicy</strong>: Policy-based access control
        </li>
      </ul>

      <h4>Infrastructure Packages</h4>

      <ul>
        <li>
          <strong>@copilot-ld/librpc</strong>: gRPC service infrastructure and
          clients
        </li>
        <li>
          <strong>@copilot-ld/libtype</strong>: Generated Protocol Buffer types
        </li>
        <li>
          <strong>@copilot-ld/libcodegen</strong>: Code generation from protobuf
          schemas
        </li>
        <li>
          <strong>@copilot-ld/libstorage</strong>: Storage abstraction (local,
          S3)
        </li>
        <li>
          <strong>@copilot-ld/libconfig</strong>: Configuration loading and
          validation
        </li>
      </ul>

      <h4>Utility Packages</h4>

      <ul>
        <li>
          <strong>@copilot-ld/libformat</strong>: Formatting and serialization
        </li>
        <li>
          <strong>@copilot-ld/libutil</strong>: Common utilities and helpers
        </li>
        <li>
          <strong>@copilot-ld/libcopilot</strong>: GitHub Copilot integration
        </li>
        <li><strong>@copilot-ld/libweb</strong>: Web server utilities</li>
        <li><strong>@copilot-ld/librepl</strong>: REPL and CLI utilities</li>
        <li>
          <strong>@copilot-ld/libperf</strong>: Performance testing utilities
        </li>
      </ul>

      <h3 id="codegen">Code Generation</h3>

      <p>
        The platform uses centralized code generation to produce type-safe
        JavaScript from Protocol Buffer schemas. The
        <code>@copilot-ld/libcodegen</code> package handles all generation.
      </p>

      <h4>Generation Process</h4>

      <ol>
        <li>
          <strong>Setup</strong>: Creates <code>generated/</code> directory with
          storage symlinks
        </li>
        <li>
          <strong>Schema Discovery</strong>: Scans <code>proto/</code> for core
          services and <code>tools/</code> for extensions
        </li>
        <li>
          <strong>Type Generation</strong>: Creates consolidated JavaScript
          types with JSDoc
        </li>
        <li>
          <strong>Service Generation</strong>: Produces base classes and typed
          clients
        </li>
        <li>
          <strong>Definition Pre-compilation</strong>: Generates runtime-ready
          gRPC service definitions
        </li>
        <li>
          <strong>Package Integration</strong>: Creates symlinks for access via
          <code>@copilot-ld/libtype</code> and <code>@copilot-ld/librpc</code>
        </li>
      </ol>

      <h4>Output Structure</h4>

      <pre>
./generated/
â”œâ”€â”€ proto/              # Copied .proto files for runtime loading
â”œâ”€â”€ types/
â”‚   â””â”€â”€ types.js        # Consolidated protobuf types
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ exports.js      # Aggregated service/client exports
â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”œâ”€â”€ service.js  # Base class
â”‚   â”‚   â””â”€â”€ client.js   # Typed client
â”‚   â””â”€â”€ definitions/
â”‚       â”œâ”€â”€ agent.js    # Pre-compiled service definition
â”‚       â””â”€â”€ exports.js  # Definition exports
â””â”€â”€ bundle.tar.gz       # Compressed archive

# Package symlinks (created at service startup)
./packages/libtype/generated/  â†’ ./generated/
./packages/librpc/generated/   â†’ ./generated/
      </pre>

      <h4>Code Generation Commands</h4>

      <pre><code># Generate everything (recommended)
npm run codegen

# Generate specific components
npm run codegen:type        # Types only
npm run codegen:service     # Service base classes
npm run codegen:client      # Client classes
npm run codegen:definition  # Service definitions</code></pre>

      <h4>Factory Function Pattern</h4>

      <p>
        Packages provide factory functions for simplified component creation:
      </p>

      <pre><code>import { createGraphIndex } from "@copilot-ld/libgraph";
import { createResourceIndex } from "@copilot-ld/libresource";

// Create with defaults
const graphIndex = createGraphIndex();
const resourceIndex = createResourceIndex();

// Advanced customization
const customResourceIndex = createResourceIndex("persistent", customPolicy);</code></pre>

      <h4>Enhanced Content Representation</h4>

      <p>
        The <code>resource.Content</code> message supports multiple formats:
      </p>

      <pre><code>message Content {
  int32 tokens = 1;
  optional string text = 2;     // Plain text
  optional string nquads = 3;   // RDF N-Quads
  optional string jsonld = 4;   // JSON-LD
}</code></pre>

      <p>
        This enables both semantic graph processing and traditional text
        operations on the same resource.
      </p>

      <h3 id="security">Security Implementation</h3>

      <h4>Authentication Mechanisms</h4>

      <h5>Service Authentication</h5>

      <p>
        All inter-service communication uses HMAC-based authentication with
        time-limited tokens:
      </p>

      <ol>
        <li>
          <strong>Token Generation</strong>: Service creates payload with ID and
          timestamp
        </li>
        <li>
          <strong>Signing</strong>: Payload signed with shared secret using HMAC
        </li>
        <li>
          <strong>Transmission</strong>: Token attached to gRPC metadata headers
        </li>
        <li>
          <strong>Verification</strong>: Receiving service validates signature
          and timestamp
        </li>
        <li>
          <strong>Expiration</strong>: Tokens expire after configured lifetime
        </li>
      </ol>

      <h5>Token Lifecycle</h5>

      <pre><code>// Token generation (simplified)
const payload = `${serviceId}:${timestamp}`;
const signature = hmac(sharedSecret, payload);
const token = `${payload}:${signature}`;

// Token verification (simplified)
const [serviceId, timestamp, signature] = token.split(':');
const expectedSignature = hmac(sharedSecret, `${serviceId}:${timestamp}`);
const isValid = secureCompare(signature, expectedSignature) && !isExpired(timestamp);</code></pre>

      <h4>Communication Security</h4>

      <h5>gRPC Internal Communication</h5>

      <ul>
        <li><strong>Protocol</strong>: gRPC with Protocol Buffers</li>
        <li>
          <strong>Authentication</strong>: HMAC signatures on every request
        </li>
        <li>
          <strong>Token Lifetime</strong>: Configurable short-lived duration
        </li>
        <li>
          <strong>Secret Management</strong>: Shared secret from environment
        </li>
        <li>
          <strong>Schema Validation</strong>: Automatic message validation
        </li>
      </ul>

      <h5>External API Communication</h5>

      <ul>
        <li>
          <strong>Client to Extensions</strong>: HTTP/HTTPS via load balancer
        </li>
        <li>
          <strong>LLM Service to APIs</strong>: HTTPS with API key
          authentication
        </li>
      </ul>

      <h4>Threat Model</h4>

      <h5>Protected Against</h5>

      <ol>
        <li>
          <strong>External Access</strong>: Backend services isolated in Docker
          network
        </li>
        <li>
          <strong>Service Impersonation</strong>: HMAC prevents unauthorized
          access
        </li>
        <li>
          <strong>Token Replay</strong>: Time-limited tokens minimize replay
          windows
        </li>
        <li>
          <strong>Request Forgery</strong>: HMAC signatures prevent tampering
        </li>
      </ol>

      <h5>Known Limitations</h5>

      <ol>
        <li>
          <strong>Shared Secret Exposure</strong>: Compromised secret bypasses
          authentication
        </li>
        <li>
          <strong>Container Compromise</strong>: Attacker gains access to shared
          secret
        </li>
        <li>
          <strong>No mTLS</strong>: gRPC communication not encrypted between
          services
        </li>
        <li>
          <strong>No Rate Limiting</strong>: Extensions must implement their own
        </li>
        <li>
          <strong>Extension Security</strong>: Primary attack surface requiring
          validation
        </li>
      </ol>

      <h4>Security Responsibilities by Layer</h4>

      <h5>Extensions</h5>

      <ul>
        <li>Input validation and sanitization</li>
        <li>Rate limiting and DDoS protection</li>
        <li>Session management</li>
        <li>CORS policy enforcement</li>
      </ul>

      <h5>Agent Service</h5>

      <ul>
        <li>Request orchestration security</li>
        <li>Service-to-service authentication enforcement</li>
        <li>Business logic security validation</li>
      </ul>

      <h5>Backend Services</h5>

      <ul>
        <li>gRPC message validation</li>
        <li>Resource usage limiting</li>
        <li>Data access controls</li>
        <li>Error handling without information disclosure</li>
      </ul>

      <h3 id="docker">Docker Build Process</h3>

      <h4>Unified Dockerfile</h4>

      <p>
        The platform uses a single parameterized Dockerfile that builds any
        service or extension:
      </p>

      <pre><code># Build any service
docker build --build-arg SERVICE_NAME=agent -t copilot-ld-agent .
docker build --build-arg SERVICE_NAME=memory -t copilot-ld-memory .

# Build any extension
docker build --build-arg SERVICE_NAME=web -t copilot-ld-web .</code></pre>

      <h4>Build Process</h4>

      <ol>
        <li>
          <strong>Base Stage</strong>: Install Node.js and system dependencies
        </li>
        <li>
          <strong>Dependencies</strong>: Copy <code>package.json</code> and
          install packages
        </li>
        <li>
          <strong>Source Copy</strong>: Copy application code and generated
          artifacts
        </li>
        <li>
          <strong>Service Selection</strong>: Use <code>SERVICE_NAME</code>
          <code>arg</code>
          to select entry point
        </li>
        <li>
          <strong>Runtime Configuration</strong>: Set <code>NODE_ENV</code> and
          expose ports
        </li>
      </ol>

      <h4>Multi-Stage Benefits</h4>

      <ul>
        <li>
          <strong>Small Images</strong>: Final images under 10 MB per service
        </li>
        <li>
          <strong>Fast Builds</strong>: Cached layers minimize rebuild time
        </li>
        <li><strong>Consistency</strong>: All services built identically</li>
        <li>
          <strong>Security</strong>: Minimal attack surface in production images
        </li>
      </ul>

      <h3 id="patterns">Development Patterns</h3>

      <h4>Service Adapter Pattern</h4>

      <p>
        Services are thin gRPC adapters around business logic packages. This
        separation enables:
      </p>

      <ul>
        <li>
          <strong>Unit Testing</strong>: Test business logic without gRPC
          infrastructure
        </li>
        <li>
          <strong>Reusability</strong>: Same logic powers services and CLI tools
        </li>
        <li>
          <strong>Framework Independence</strong>: Business logic has no service
          dependencies
        </li>
      </ul>

      <h4>Index Pattern</h4>

      <p>
        Indexes extend <code>IndexBase</code> and implement standard methods:
      </p>

      <pre><code>class CustomIndex extends IndexBase {
  async addItem(item) {
    // Add item to index
  }

  async queryItems(query) {
    // Query and return matching items
  }
}</code></pre>

      <h4>Storage Abstraction</h4>

      <p>
        The <code>@copilot-ld/libstorage</code> package provides unified storage
        access:
      </p>

      <pre><code>import { createStorage } from "@copilot-ld/libstorage";

// Automatically uses local or S3 based on config
const storage = createStorage();

await storage.write("path/to/file.json", data);
const data = await storage.read("path/to/file.json");</code></pre>

      <h3 id="extensions">Extension Development</h3>

      <h4>Creating New Extensions</h4>

      <p>
        Extensions are application adapters that expose the platform through
        different interfaces:
      </p>

      <ol>
        <li>
          <strong>Create Directory</strong>:
          <code>extensions/your-extension/</code>
        </li>
        <li>
          <strong>Implement Interface</strong>: REST API, Teams bot, Slack app,
          etc.
        </li>
        <li>
          <strong>Use Agent Client</strong>: Import
          <code>@copilot-ld/librpc</code> to call Agent service
        </li>
        <li>
          <strong>Add to Docker</strong>: Ensure unified Dockerfile supports
          your extension
        </li>
      </ol>

      <h4>Example Extension Structure</h4>

      <pre>
extensions/your-extension/
â”œâ”€â”€ index.js           # Entry point
â”œâ”€â”€ routes.js          # Request handlers
â”œâ”€â”€ middleware.js      # Authentication, validation
â””â”€â”€ package.json       # Extension-specific dependencies
      </pre>

      <h3 id="tools">Tool Development</h3>

      <h4>Creating Custom Tools</h4>

      <p>
        Tools extend the platform with custom functionality accessible to the
        agent:
      </p>

      <ol>
        <li>
          <strong>Define Protocol</strong>: Create
          <code>tools/your-tool.proto</code>
        </li>
        <li>
          <strong>Implement Service</strong>: Create
          <code>tools/your-tool/index.js</code>
        </li>
        <li>
          <strong>Configure Tool</strong>: Add entry to
          <code>config/tools.yml</code>
        </li>
        <li>
          <strong>Regenerate Code</strong>: Run <code>npm run codegen</code>
        </li>
      </ol>

      <h4>Tool Configuration Example</h4>

      <pre><code># config/tools.yml
your_tool:
  method: "your-tool.YourTool.Execute"
  request: "your-tool.YourToolRequest"
  purpose: |
    Brief description of what the tool does.
  applicability: |
    When the agent should use this tool.
  instructions: |
    How to use the tool effectively.</code></pre>

      <h3 id="testing">Testing Strategies</h3>

      <h4>Unit Testing</h4>

      <p>Test business logic packages independently:</p>

      <pre><code>import { AgentMind } from "@copilot-ld/libagent";

describe("AgentMind", () => {
  it("assembles context correctly", async () => {
    const mind = new AgentMind(mockConfig);
    const context = await mind.assembleContext(conversation);
    expect(context.messages).toHaveLength(5);
  });
});</code></pre>

      <h4>Integration Testing</h4>

      <p>Test service communication:</p>

      <pre><code>import { createAgentClient } from "@copilot-ld/librpc";

describe("Agent Service", () => {
  it("processes requests end-to-end", async () => {
    const client = createAgentClient();
    const response = await client.process({ message: "test" });
    expect(response.completion).toBeDefined();
  });
});</code></pre>

      <h4>Performance Testing</h4>

      <p>Use <code>@copilot-ld/libperf</code> for benchmarks:</p>

      <pre><code>import { benchmark } from "@copilot-ld/libperf";

await benchmark("Vector search", async () => {
  await vectorService.queryByContent("test query");
});</code></pre>

      <h3 id="next">Next Steps</h3>

      <ul>
        <li>
          <strong><a href="configuration.html">Configuration</a></strong
          >: Environment setup and configuration options
        </li>
        <li>
          <strong><a href="processing.html">Processing</a></strong
          >: Knowledge base preparation workflows
        </li>
        <li>
          <strong><a href="development.html">Development</a></strong
          >: Local development environment
        </li>
        <li>
          <strong><a href="deployment.html">Deployment</a></strong
          >: Production deployment strategies
        </li>
      </ul>
    </main>
    <footer class="container">
      <p>Â© D. Olsson</p>
    </footer>
  </body>
</html>
