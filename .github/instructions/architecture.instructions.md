---
applyTo: "**"
---

# Architecture Instructions

## Purpose Declaration

This file provides comprehensive architectural guidance for all files in this
project to ensure consistent adherence to the microservices-based, gRPC-enabled
platform design with proper service organization and communication patterns.

## Core Principles

1. **Microservices Architecture**: Every service must follow
   single-responsibility principle with clear boundaries
2. **gRPC Communication**: All inter-service communication must use gRPC with
   Protocol Buffers for type safety
3. **Framework-Agnostic Packages**: All code in `/packages` must be
   framework-independent and reusable
4. **Service Isolation**: Services must be stateless and maintain no persistent
   connections between requests
5. **Parallel Processing**: Operations must be designed for concurrent execution
   where possible
6. **Core System Integrity**: The core system (services in `/services`, packages
   in `/packages`, proto schemas in `/proto`) must remain **completely
   unchanged** when tools are added to `/tools`. Tools extend the platform
   without modifying core components. Generated code must adapt to work with the
   existing core system, never the reverse.

## Implementation Requirements

### Directory Structure Requirements

```
./services/         # gRPC services only
./extensions/       # REST API adapters only
./packages/         # Framework-agnostic logic only
./scripts/          # Development utilities only
./data/             # Static definitions and indices only
./proto/            # Protocol Buffer schemas only
./tools/            # Custom tools that extend the core system
```

### Service Structure Pattern

All services are generated with a `service.js` Base class and a `client.js` that
encapsulate gRPC details. Implementations must extend the generated `*Base` and
override RPC methods using typed messages from `@copilot-ld/libtype`.

```javascript
/* eslint-env node */
import { ServiceConfig } from "@copilot-ld/libconfig";
import { vector } from "@copilot-ld/libtype";
import { VectorIndex } from "@copilot-ld/libvector";
import { createStorage } from "@copilot-ld/libstorage";

import { VectorBase } from "./service.js"; // generated by codegen

class VectorService extends VectorBase {
  #contentIndex;

  constructor(config, contentIndex, grpcFn, authFn, logFn) {
    super(config, grpcFn, authFn, logFn);
    this.#contentIndex = contentIndex;
  }

  /**
   * @param {vector.QueryItemsRequest} req
   * @returns {Promise<vector.QueryItemsResponse>}
   */
  async QueryItems(req) {
    const identifiers = await this.#contentIndex.queryItems(req.vector, {
      threshold: req.filter?.threshold ?? 0.3,
      limit: req.filter?.limit ?? 0,
    });
    return { identifiers };
  }
}

// Bootstrap
const config = await ServiceConfig.create("vector", {
  threshold: 0.3,
  limit: 0,
});
const vectors = createStorage("vectors");
const contentIndex = new VectorIndex(vectors, "content.jsonl");
await new VectorService(config, contentIndex).start();
```

This pattern is generated and maintained by the code generation workflow. Only
the implementation class in `index.js` should contain custom logic.

### Code Generation Workflow

Service bases, clients, and typed messages are generated from `proto/*.proto`
and optional tool schemas in `tools/*.proto` that **extend the core system**:

```bash
npm run codegen        # Generate all (types, services, clients)
npm run codegen:type   # Generate @copilot-ld/libtype
npm run codegen:service# Generate services/*/service.js
npm run codegen:client # Generate services/*/client.js
```

**Critical Constraint**: Tool definitions in `/tools` are **extensions to the
core platform** and provide additional functionality beyond the base system
capabilities. **Generated code from tools must adapt to work with the existing
core system** - the core system packages, services, and type definitions must
never be modified to accommodate new tools. This ensures platform stability and
prevents tool additions from breaking existing functionality.

**Note**: Generated code should always import enhanced types from core packages
(e.g., `@copilot-ld/libtype`) rather than raw generated types to ensure access
to all core system enhancements like monkey patches and utility functions.

### Package Export Pattern

All packages must export through a main `index.js`:

```javascript
// External imports first
import thirdPartyLibrary from "library";

// Internal imports second (alphabetical)
import { helperFunction } from "./helpers/index.js";

// Implementation
export class PackageImplementation {
  method() {
    // Implementation
  }
}

// Re-exports
export { helperFunction };
```

### Protocol Buffer Schema Requirements

All .proto files must define complete service interfaces:

```protobuf
syntax = "proto3";

package copilot-ld.servicename;

service ServiceName {
  rpc MethodName(MethodRequest) returns (MethodResponse);
}

message MethodRequest {
  string field_name = 1;
  repeated string array_field = 2;
}

message MethodResponse {
  string result = 1;
  int32 status_code = 2;
}
```

## Best Practices

### Protobuf Object Creation Patterns

All protobuf types must be created using `Type.fromObject()` instead of
`new Type()` to ensure proper deep initialization and monkey patch activation:

```javascript
/* eslint-env node */
import { common, resource, tool } from "@copilot-ld/libtype";

// ✅ CORRECT - Use fromObject for deep initialization
const message = common.Message.fromObject({
  role: "user",
  content: "Hello world", // Automatically converted to { text: "Hello world" }
});

const identifier = resource.Identifier.fromObject({
  name: "example",
  type: "tool.ToolFunction",
});

// ❌ INCORRECT - Constructor only does flat initialization
const badMessage = new common.Message({
  role: "user",
  content: "Hello world", // Will cause validation errors
});
```

**Why fromObject() is Required:**

- Activates monkey patches that handle type conversions (e.g., string → Content
  object)
- Ensures proper nested object initialization
- Provides validation and error handling
- Maintains consistency with gRPC serialization expectations

**When to Use Each Pattern:**

- `Type.fromObject(data)` - For all normal object creation (99% of cases)
- `new Type(data)` - Only when specifically avoiding deep initialization to
  preserve non-proto fields

### Service Communication Patterns

Agent service must coordinate all operations through parallel execution:

```javascript
class AgentService {
  #memoryService;
  #llmService;
  #vectorService;

  constructor(memoryService, llmService, vectorService) {
    if (!memoryService) throw new Error("memoryService is required");
    if (!llmService) throw new Error("llmService is required");
    if (!vectorService) throw new Error("vectorService is required");

    this.#memoryService = memoryService;
    this.#llmService = llmService;
    this.#vectorService = vectorService;
  }

  async processRequest(request) {
    // Parallel operations
    const [memoryWindow, embeddings] = await Promise.all([
      this.#memoryService.get(request),
      this.#llmService.createEmbeddings(request.query),
    ]);

    // Direct vector query
    const vectorResults = await this.#vectorService.queryItems(embeddings);

    return { chunks: vectorResults.chunks, usage: vectorResults.usage };
  }
}
```

### File Organization Standards

Import order requirements:

```javascript
/* eslint-env node */
// 1. External libraries (alphabetical)
import grpc from "@grpc/grpc-js";
import NodeCache from "node-cache";

// 2. Internal packages (alphabetical)
import { Config } from "@copilot-ld/libconfig";
import { Service } from "@copilot-ld/librpc";

// 3. Local imports (relative paths, alphabetical)
```

### Network Isolation Requirements

- **Backend services**: Must be on internal network only, no host port exposure
- **Extensions**: Must bridge external and internal networks
- **External APIs**: Must be accessed only through dedicated service clients

## Explicit Prohibitions

### Forbidden Architectural Patterns

1. **DO NOT** create direct dependencies between backend services (must go
   through Agent)
2. **DO NOT** expose backend service ports to the host network
3. **DO NOT** use REST for inter-service communication (gRPC only)
4. **DO NOT** maintain state within service instances
5. **DO NOT** create circular dependencies between packages
6. **DO NOT** put framework-specific code in `/packages` directory
7. **DO NOT** bypass the Agent service for complex multi-service operations
8. **DO NOT** modify core system components (`/services`, `/packages`, `/proto`)
   to accommodate new tools - tools must adapt to the existing core system
9. **DO NOT** import raw generated types when enhanced core types are
   available - always use core packages like `@copilot-ld/libtype` to access
   enhanced functionality
10. **DO NOT** use `new Type()` constructor for protobuf types - always use
    `Type.fromObject()` for proper initialization and monkey patch activation

### Alternative Approaches

- Instead of direct service calls → Route through Agent service orchestration
- Instead of REST inter-service → Use gRPC with Protocol Buffers
- Instead of stateful services → Design for stateless request processing
- Instead of framework coupling → Create framework-agnostic abstractions
- Instead of modifying core system for tools → Design tools to work with
  existing core system APIs and enhanced types
- Instead of importing raw generated types → Use enhanced core packages like
  `@copilot-ld/libtype` for full functionality
- Instead of `new Type()` constructors → Use `Type.fromObject()` for proper
  protobuf object initialization

## Comprehensive Examples

### Complete Service Implementation

```javascript
/* eslint-env node */
import { ServiceConfig } from "@copilot-ld/libconfig";
import { VectorIndex } from "@copilot-ld/libvector";
import { createStorage } from "@copilot-ld/libstorage";
import { vector } from "@copilot-ld/libtype";

import { VectorBase } from "./service.js";

class VectorService extends VectorBase {
  #contentIndex;
  constructor(config, contentIndex, grpcFn, authFn, logFn) {
    super(config, grpcFn, authFn, logFn);
    this.#contentIndex = contentIndex;
  }

  /** @param {vector.QueryItemsRequest} req */
  async QueryItems(req) {
    const identifiers = await this.#contentIndex.queryItems(
      req.vector,
      req.filter || {},
    );
    return { identifiers };
  }
}

const config = await ServiceConfig.create("vector");
const index = new VectorIndex(createStorage("vectors"), "content.jsonl");
await new VectorService(config, index).start();
```

### Complete Package Implementation

```javascript
/* eslint-env node */
export class MemoryCache {
  #cache;
  #ttls;
  #defaultTtl;

  constructor(options = {}) {
    this.#cache = new Map();
    this.#ttls = new Map();
    this.#defaultTtl = options.defaultTtl || 3600000;
  }

  async get(key) {
    if (this.isExpired(key)) {
      await this.delete(key);
      return null;
    }
    return this.#cache.get(key) || null;
  }

  async set(key, value, ttl) {
    this.#cache.set(key, value);
    this.#ttls.set(key, Date.now() + (ttl || this.#defaultTtl));
  }

  async delete(key) {
    this.#cache.delete(key);
    this.#ttls.delete(key);
  }

  isExpired(key) {
    const ttl = this.#ttls.get(key);
    return ttl && Date.now() > ttl;
  }
}

export class PersistentCache {
  #storage;
  #defaultTtl;

  constructor(storage, options = {}) {
    this.#storage = storage;
    this.#defaultTtl = options.defaultTtl || 3600000;
  }

  async get(key) {
    const value = await this.#storage.get(key);
    return value || null;
  }

  async set(key, value, ttl) {
    await this.#storage.set(key, value, ttl || this.#defaultTtl);
  }

  async delete(key) {
    await this.#storage.delete(key);
  }
}

export function createCache(type, storage, options) {
  switch (type) {
    case "memory":
      return new MemoryCache(options);
    case "persistent":
      if (!storage) {
        throw new Error("Storage backend required for persistent cache");
      }
      return new PersistentCache(storage, options);
    default:
      throw new Error(`Unsupported cache type: ${type}`);
  }
}
```

### Complete Extension Implementation

```javascript
/* eslint-env node */
import { Hono } from "hono";
import { serve } from "@hono/node-server";
import { cors } from "hono/cors";

import { AgentClient } from "../../generated/services/agent/client.js";
import { ExtensionConfig, ServiceConfig } from "@copilot-ld/libconfig";
import {
  createValidationMiddleware,
  createCorsMiddleware,
} from "@copilot-ld/libweb";
import { common } from "@copilot-ld/libtype";

const extConfig = await ExtensionConfig.create("web");
const agentClient = new AgentClient(await ServiceConfig.create("agent"));
const app = new Hono();

// Create middleware instances
const validationMiddleware = createValidationMiddleware(extConfig);
const corsMiddleware = createCorsMiddleware(extConfig);

// CORS middleware
app.use(
  "/api/*",
  corsMiddleware.create({
    origin: ["http://localhost:3000"],
    allowMethods: ["POST"],
  }),
);

app.post("/api/chat", async (c) => {
  const body = await c.req.json();

  const req = {
    messages: [
      common.Message.fromObject({ role: "user", content: body.message }),
    ],
    github_token: await extConfig.githubToken(),
  };

  const resp = await agentClient.ProcessRequest(req);
  return c.json({ status: "success", data: resp });
});

serve({ fetch: app.fetch, port: extConfig.port, hostname: extConfig.host });
```
