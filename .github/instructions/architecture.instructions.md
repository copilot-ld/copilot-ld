---
applyTo: "**"
---

# Architecture Instructions

## Purpose Declaration

This file provides comprehensive architectural guidance for all files in this
project to ensure consistent adherence to the microservices-based, gRPC-enabled
platform design with proper service organization and communication patterns.

## Core Principles

1. **Microservices Architecture**: Every service must follow
   single-responsibility principle with clear boundaries
2. **gRPC Communication**: All inter-service communication must use gRPC with
   Protocol Buffers for type safety
3. **Framework-Agnostic Packages**: All code in `/packages` must be
   framework-independent and reusable
4. **Service Isolation**: Services must be stateless and maintain no persistent
   connections between requests
5. **Parallel Processing**: Operations must be designed for concurrent execution
   where possible

## Implementation Requirements

### Directory Structure Requirements

```
./services/         # gRPC services only
./extensions/       # REST API adapters only
./packages/         # Framework-agnostic logic only
./scripts/          # Development utilities only
./data/             # Static definitions and indices only
./proto/            # Protocol Buffer schemas only
```

### Service Structure Pattern

All services are generated with a `service.js` Base class and a `client.js` that
encapsulate gRPC details. Implementations must extend the generated `*Base` and
override RPC methods using typed messages from `@copilot-ld/libtype`.

```javascript
/* eslint-env node */
import { ServiceConfig } from "@copilot-ld/libconfig";
import { vector } from "@copilot-ld/libtype";
import { VectorIndex } from "@copilot-ld/libvector";
import { storageFactory } from "@copilot-ld/libstorage";

import { VectorBase } from "./service.js"; // generated by codegen

class VectorService extends VectorBase {
  #contentIndex;

  constructor(config, contentIndex, grpcFn, authFn, logFn) {
    super(config, grpcFn, authFn, logFn);
    this.#contentIndex = contentIndex;
  }

  /**
   * @param {vector.QueryItemsRequest} req
   * @returns {Promise<vector.QueryItemsResponse>}
   */
  async QueryItems(req) {
    const identifiers = await this.#contentIndex.queryItems(req.vector, {
      threshold: req.filter?.threshold ?? 0.3,
      limit: req.filter?.limit ?? 0,
    });
    return { identifiers };
  }
}

// Bootstrap
const config = await ServiceConfig.create("vector", {
  threshold: 0.3,
  limit: 0,
});
const vectors = storageFactory("vectors");
const contentIndex = new VectorIndex(vectors, "content.jsonl");
await new VectorService(config, contentIndex).start();
```

This pattern is generated and maintained by the code generation workflow. Only
the implementation class in `index.js` should contain custom logic.

### Code Generation Workflow

Service bases, clients, and typed messages are generated from `proto/*.proto`:

```bash
npm run codegen        # Generate all (types, services, clients)
npm run codegen:type   # Generate @copilot-ld/libtype
npm run codegen:service# Generate services/*/service.js
npm run codegen:client # Generate services/*/client.js
```

### Package Export Pattern

All packages must export through a main `index.js` with interface definitions:

```javascript
// External imports first
import thirdPartyLibrary from "library";

// Internal imports second (alphabetical)
import { helperFunction } from "./helpers/index.js";
import { PackageInterface } from "./types.js";

// Implementation
export class PackageImplementation extends PackageInterface {
  method() {
    // Implementation
  }
}

// Re-exports (including interface)
export { PackageInterface, helperFunction };
```

### Protocol Buffer Schema Requirements

All .proto files must define complete service interfaces:

```protobuf
syntax = "proto3";

package copilot-ld.servicename;

service ServiceName {
  rpc MethodName(MethodRequest) returns (MethodResponse);
}

message MethodRequest {
  string field_name = 1;
  repeated string array_field = 2;
}

message MethodResponse {
  string result = 1;
  int32 status_code = 2;
}
```

## Best Practices

### Service Communication Patterns

Agent service must coordinate all operations through parallel execution:

```javascript
class AgentService {
  constructor(historyService, llmService, vectorService) {
    this.historyService = historyService;
    this.llmService = llmService;
    this.vectorService = vectorService;
  }

  async processRequest(request) {
    // Parallel operations
    const [historyData, embeddings] = await Promise.all([
      this.historyService.getHistory(request),
      this.llmService.createEmbeddings(request.query),
    ]);

    // Direct vector query (no scope resolution needed)
    const vectorResults = await this.vectorService.queryItems(embeddings);

    return { chunks: vectorResults.chunks, usage: vectorResults.usage };
  }
}
```

### File Organization Standards

Import order requirements:

```javascript
/* eslint-env node */
// 1. External libraries (alphabetical)
import grpc from "@grpc/grpc-js";
import NodeCache from "node-cache";

// 2. Internal packages (alphabetical)
import { Config } from "@copilot-ld/libconfig";
import { Service } from "@copilot-ld/libservice";

// 3. Local imports (relative paths, alphabetical)
import { DatabaseInterface } from "./types.js";
```

### Network Isolation Requirements

- **Backend services**: Must be on internal network only, no host port exposure
- **Extensions**: Must bridge external and internal networks
- **External APIs**: Must be accessed only through dedicated service clients

## Explicit Prohibitions

### Forbidden Architectural Patterns

1. **DO NOT** create direct dependencies between backend services (must go
   through Agent)
2. **DO NOT** expose backend service ports to the host network
3. **DO NOT** use REST for inter-service communication (gRPC only)
4. **DO NOT** maintain state within service instances
5. **DO NOT** create circular dependencies between packages
6. **DO NOT** put framework-specific code in `/packages` directory
7. **DO NOT** bypass the Agent service for complex multi-service operations

### Alternative Approaches

- Instead of direct service calls → Route through Agent service orchestration
- Instead of REST inter-service → Use gRPC with Protocol Buffers
- Instead of stateful services → Design for stateless request processing
- Instead of framework coupling → Create framework-agnostic abstractions

## Comprehensive Examples

### Complete Service Implementation

```javascript
/* eslint-env node */
import { ServiceConfig } from "@copilot-ld/libconfig";
import { VectorIndex } from "@copilot-ld/libvector";
import { storageFactory } from "@copilot-ld/libstorage";
import { vector } from "@copilot-ld/libtype";

import { VectorBase } from "./service.js";

class VectorService extends VectorBase {
  #contentIndex;
  constructor(config, contentIndex, grpcFn, authFn, logFn) {
    super(config, grpcFn, authFn, logFn);
    this.#contentIndex = contentIndex;
  }

  /** @param {vector.QueryItemsRequest} req */
  async QueryItems(req) {
    const identifiers = await this.#contentIndex.queryItems(
      req.vector,
      req.filter || {},
    );
    return { identifiers };
  }
}

const config = await ServiceConfig.create("vector");
const index = new VectorIndex(storageFactory("vectors"), "content.jsonl");
await new VectorService(config, index).start();
```

### Complete Package Implementation

```javascript
/* eslint-env node */
export class CacheInterface {
  async get(key) {
    throw new Error("Not implemented");
  }

  async set(key, value, ttl) {
    throw new Error("Not implemented");
  }

  async delete(key) {
    throw new Error("Not implemented");
  }
}

export class MemoryCache extends CacheInterface {
  constructor(options = {}) {
    super();
    this.cache = new Map();
    this.ttls = new Map();
    this.defaultTtl = options.defaultTtl || 3600000;
  }

  async get(key) {
    if (this.isExpired(key)) {
      await this.delete(key);
      return null;
    }
    return this.cache.get(key) || null;
  }

  async set(key, value, ttl) {
    this.cache.set(key, value);
    this.ttls.set(key, Date.now() + (ttl || this.defaultTtl));
  }

  async delete(key) {
    this.cache.delete(key);
    this.ttls.delete(key);
  }

  isExpired(key) {
    const ttl = this.ttls.get(key);
    return ttl && Date.now() > ttl;
  }
}

export class PersistentCache extends CacheInterface {
  constructor(storage, options = {}) {
    super();
    this.storage = storage;
    this.defaultTtl = options.defaultTtl || 3600000;
  }

  async get(key) {
    const value = await this.storage.get(key);
    return value || null;
  }

  async set(key, value, ttl) {
    await this.storage.set(key, value, ttl || this.defaultTtl);
  }

  async delete(key) {
    await this.storage.delete(key);
  }
}

export function createCache(type, storage, options) {
  switch (type) {
    case "memory":
      return new MemoryCache(options);
    case "persistent":
      if (!storage) {
        throw new Error("Storage backend required for persistent cache");
      }
      return new PersistentCache(storage, options);
    default:
      throw new Error(`Unsupported cache type: ${type}`);
  }
}
```

### Complete Extension Implementation

```javascript
/* eslint-env node */
import { Hono } from "hono";
import { serve } from "@hono/node-server";
import { cors } from "hono/cors";

import { AgentClient } from "@copilot-ld/agent";
import { ExtensionConfig, ServiceConfig } from "@copilot-ld/libconfig";
import { createSecurityMiddleware } from "@copilot-ld/libweb";
import { common } from "@copilot-ld/libtype";

const extConfig = await ExtensionConfig.create("web");
const agentClient = new AgentClient(await ServiceConfig.create("agent"));
const app = new Hono();

// Security and CORS
const security = createSecurityMiddleware(extConfig);
app.use("/api/*", security.createRateLimitMiddleware());
app.use(
  "/api/*",
  cors({ origin: ["http://localhost:3000"], allowMethods: ["POST"] }),
);

app.post("/api/chat", async (c) => {
  const body = await c.req.json();
  await agentClient.ensureReady();

  const req = {
    messages: [
      common.MessageV2.fromObject({ role: "user", content: body.message }),
    ],
    github_token: await extConfig.githubToken(),
  };

  const resp = await agentClient.ProcessRequest(req);
  return c.json({ status: "success", data: resp });
});

serve({ fetch: app.fetch, port: extConfig.port, hostname: extConfig.host });
```
