/* eslint-env node */
import { createLogger } from "@copilot-ld/libutil";
import { {{#importNamespaces}}{{name}}{{^isLast}}, {{/isLast}}{{/importNamespaces}} } from "@copilot-ld/libtype";

/**
 * Base class for {{serviceName}} service implementation
 */
export class {{className}} {
  config;
  #logger;

  /**
   * Creates a new {{serviceName}} service instance
   * @param { object } config - Service configuration
   * @param {(namespace: string) => import("@copilot-ld/libutil").LoggerInterface} [logFn] - Optional log factory
   */
  constructor(config, logFn = createLogger) {
    if (!config) throw new Error("config is required");
    this.config = config;
    this.#logger = logFn(config.name);
  }

  /**
   * Logs a debug message.
   * @param { string } message - The message to log
   * @param { object } context - Additional context to include in the log
   */
  debug(message, context) {
    this.#logger.debug(message, context);
  }

{{#methods}}
  /**
   * Must be implemented by subclass
   * @param { {{requestTypeNamespace}}.{{requestType}} } _{{paramName}} - Request parameters
   * @returns { Promise<{{responseTypeNamespace}}.{{responseType}}> } Response object
   */
  async {{name}}(_{{paramName}}) {
    throw new Error("{{name}} not implemented");
  }

{{/methods}}
  /**
   * Creates gRPC handlers for this service instance
   * @returns { object } Map of method names to handler functions
   */
  getHandlers() {
    return {
{{#methods}}
      {{name}}: async (call) => {
        const error = {{requestTypeNamespace}}.{{requestType}}.verify(call.request);
        if (error) throw new Error(`{{name}}: ${error}`);
        const req = {{requestTypeNamespace}}.{{requestType}}.fromObject(call.request);
        return await this.{{name}}(req);
      },
{{/methods}}
    };
  }
}
